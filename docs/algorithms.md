# Algorithms

- definição: sequência de passos ou instruções necessários para resolver um problema bem definido
- cada programa ou software consiste em pequenos algoritimos
- independente da sequência de passos, o resultado final deveria (na maioria das vezes) ser igual dado a mesma entrada
- Best possible solution always looking for best performance with minimum amount of code and least memory usage

## Commom Algorithms

1. Logarithm (Complexity Analysis)
2. Graph Traversals (Breadth-first search BFS and Depth-first search DFS)
3. Searching Algorithms (Linear and Binary)
4. Sliding Window (String problems solving)
5. Recursion
6. Inverting a binary tree
7. Reverse a Linked List
8. Suffix Trees (String problems solving)
9. Dynamic Programming (DP)
10. Sorting Algorithms (Quick, Merge, Bubble)

# Sorting Algorithms

- Insertion Sort is best for small problem sizes or nearly-sorted data.
- Selection Sort is best when swapping items is very costly.
- Bubble Sort is similar to Insertion Sort with slightly more overhead.
- Shell Sort has low overhead and may be good for small data sets.
- Merge Sort can be excellent if using O(n) extra space is OK.
- Heap Sort is simple, fast, and sorts in-place, but it is not stable.
- Quick Sort is a good general-purpose sort with low overhead.
- Quick3 is the preferred version of Quick Sort because it is adaptive.
- Dual Pivot Quick Sort is a bit faster than the original Quick Sort.
- Why is Quick Sort so popular? It’s on average a very fast algorithm.
- Tim Sort is a blazing-fast, space-efficient, stable sorting algorithm.

https://medium.com/coding-at-dawn/sorts-in-60-seconds-speedy-javascript-interview-answers-on-sorting-acb72bdea8a2
https://www.geeksforgeeks.org/why-quick-sort-preferred-for-arrays-and-merge-sort-for-linked-lists/
